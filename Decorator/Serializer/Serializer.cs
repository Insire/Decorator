using Decorator.Attributes;
using Decorator.Exceptions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Decorator {
	public static class Serializer<TClass>
		where TClass : class {
		static Serializer() {
			if (!typeof(TClass).HasAttribute<MessageAttribute>(out var _)) throw new DecoratorException("lmao u should fhave an atrib");
		}

		public static BaseMessage Serialize(TClass itm)
			=> Serializer.Serialize<TClass>(itm);

		public static BaseMessage Serialize(IEnumerable<TClass> items)
			=> Serializer.Serialize<TClass>(items);
	}

	/// <summary>
	/// A serializer for the lazy - please try to use the generic serializer class whenever you can in your own code
	/// ( it's ok for me, the creator of the library to use this class, but i discourage you from doing it :3
	/// 
	/// at some point in the future this class may become obsolete
	/// </summary>
	/// <autogeneratedoc />
	public static class Serializer {
		public static BaseMessage Serialize<TClass>(TClass itm)
			where TClass : class {
			var def = Deserializer.TypeManager.GetDefinitionFor<TClass>();

			var data = new object[def.MaxCount];

			foreach (var i in def.Properties)
				data[(int)i.Position] = i.Get(itm);

			return new BasicMessage(def.Type, data);
		}

		public static BaseMessage Serialize<TClass>(IEnumerable<TClass> items)
			where TClass : class {
			var def = Deserializer.TypeManager.GetDefinitionFor<TClass>();

			var itms = items.ToArray();

			var objs = new object[itms.Length * def.MaxCount];

			if (objs.Length == 0) return new BasicMessage(def.Type);

			for (int i = 0; i < itms.Length; i++)
				foreach (var j in def.Properties)
					objs[(i * def.MaxCount) + (int)j.Position] = j.Get(itms[i]);

			return new BasicMessage(def.Type, objs);
		}
	}
}

using Decorator.Attributes;
using Decorator.Exceptions;
using System;
using System.Collections.Generic;

namespace Decorator {

	/// <summary>Manages message types and also a good chunk of the internal deserialization code.</summary>
	public class MessageManager {

		public MessageManager()
			=> this.Cache = new Cache<Type, MessageDefinition>();

		/// <summary>Gets the cache.</summary>
		/// <value>The cache.</value>
		/// <autogeneratedoc />
		public Cache<Type, MessageDefinition> Cache { get; }

		/// <summary>Gets the definition for <typeparamref name="T"/>.</summary>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		/// <autogeneratedoc />
		public MessageDefinition GetDefinitionFor<T>()
			=> GetDefinitionFor(typeof(T));

		/// <summary>
		/// Deserializes a BaseMessage to a <typeparamref name="T" />.
		/// Make sure you're ran <see cref="MessageManager.QualifiesAsType{T}(BaseMessage)" /> before executing this to ensure that
		/// the <see cref="BaseMessage" /> will deserialize correctly..
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="m">The message.</param>
		/// <returns></returns>
		public T DeserializeToType<T>(BaseMessage m)
					where T : new()
			=> (T)DeserializeToType(typeof(T), m);

		/// <summary>Ensures that a <see cref="BaseMessage" /> can be deserialized as a <typeparamref name="T" /></summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="m">The message.</param>
		/// <returns></returns>
		public bool QualifiesAsType<T>(BaseMessage m)
			=> QualifiesAsType(typeof(T), m);

		/// <summary>Qualifieses the type of as repeatable.</summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="m">The m.</param>
		/// <returns></returns>
		/// <autogeneratedoc />
		public bool QualifiesAsRepeatableType<T>(BaseMessage m)
					=> QualifiesAsRepeatableType(typeof(T), m);

		public IEnumerable<T> DeserializeRepeatableToType<T>(BaseMessage m) where T : new()
			=> CastFrom<T>(this.DeserializeRepeatableToType(typeof(T), m));

		public MessageDefinition GetDefinitionFor(Type t)
							=> this.Cache.Retrieve(t, () => {
								if (!t.HasAttribute<MessageAttribute>(out var msgAttrib)) throw new MissingAttributeException(typeof(MessageAttribute), t);

								var type = msgAttrib.Type;

								var repAttribs = t.GetAttributesOf<RepeatableAttribute>();

								var msgProps = new List<MessageProperty>();

								foreach (var i in t.GetPositions())
									msgProps.Add(new MessageProperty(
										i.GetAttributesOf<PositionAttribute>()[0].Position, // pos
										i.GetAttributesOf<RequiredAttribute>().Length > 0 || // required
										!(i.GetAttributesOf<OptionalAttribute>().Length > 0),
										i.PropertyType,
										i));

								return new MessageDefinition(type, msgProps, repAttribs.Length > 0);
							});

		public bool QualifiesAsType(Type t, BaseMessage m) {
			if (!t.HasAttribute<MessageAttribute>(out var _)) return false;

			return QualifiesAsTypeWithoutMessageAttributeCheck(t, m);
		}

		public bool QualifiesAsRepeatableType(Type t, BaseMessage m) {
			if (!t.HasAttribute<MessageAttribute>(out var _)) return false;

			var def = this.GetDefinitionFor(t);

			if (def.Type != m.Type ||

				!def.Repeatable ||

				// prevent divide by zero exceptions lol
				def.MaxCount == 0 ||

				m.Count % def.MaxCount != 0) return false;

			for (uint i = 0; i < m.Count / def.MaxCount; i++) {
				var args = new object[def.MaxCount];

				Array.Copy(m.Arguments, i * def.MaxCount, args, 0, def.MaxCount);

				var msgCopy = new BasicMessage(m.Type, args);

				if (!QualifiesAsTypeWithoutMessageAttributeCheck(t, msgCopy)) return false;
			}

			return true;
		}

		public object DeserializeToType(Type t, BaseMessage m) {
			// we assume that QualifiesAsType has already been called

			var instance = ReflectionHelper.Create(t)();

			var def = this.GetDefinitionFor(t);

			foreach (var i in def.Properties) {
				if (PropertyQualifies(i, m))
					i.Set(instance, m.Arguments[i.Position]);
			}

			return instance;
		}

		public IEnumerable<object> DeserializeRepeatableToType(Type t, BaseMessage m) {
			var def = this.GetDefinitionFor(t);

			for (uint i = 0; i < m.Count / def.MaxCount; i++) {
				var args = new object[def.MaxCount];

				Array.Copy(m.Arguments, i * def.MaxCount, args, 0, def.MaxCount);

				var msgCopy = new BasicMessage(m.Type, args);

				yield return DeserializeToType(t, msgCopy);
			}
		}

		private bool QualifiesAsTypeWithoutMessageAttributeCheck(Type t, BaseMessage m) {
			var def = this.GetDefinitionFor(t);

			//TODO: optional attributes at the end of a message shouldn't have to check MaxCount
			if (m?.Type != def.Type ||
				m?.Count != def.MaxCount) return false;

			foreach (var i in def.Properties)
				if (i.State == TypeRequiredness.Required &&
					!PropertyQualifies(i, m)) return false;

			return true;
		}

		private bool PropertyQualifies(MessageProperty prop, BaseMessage m)
			=> (prop.PropertyType == m?.Arguments[prop.Position]?.GetType());

		private static IEnumerable<T> CastFrom<T>(IEnumerable<object> objs) {
			foreach (var i in objs)
				yield return (T)i;
		}
	}
}
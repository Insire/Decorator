using System;
using System.Collections.Generic;
using System.Reflection;

namespace Decorator {

	/// <summary>
	/// Deserializes any message to a type.
	/// </summary>
	/// <typeparam name="TClass">The type of the class.</typeparam>
	/// <autogeneratedoc />
	public static class Deserializer {
		private static FunctionWrapper _tryDeserialize;
		private static FunctionWrapper _tryDeserializeRepeatable;

		static Deserializer() {
			var methods = typeof(Deserializer)
							.GetMethods();

			var genericTType = typeof(object).MakeByRefType();
			var genericIEnumerableTType = typeof(object[]).MakeByRefType();

			// TODO: put the 'foreach' precursor stuff in a function, not the HandleParam stuff

			foreach (var method in methods)
				if (method.IsGenericMethodDefinition)
					foreach (var parameter in method.MakeGenericMethod(typeof(object))
										.GetParameters())
						HandleParam(genericTType, genericIEnumerableTType, method, parameter);
		}

		private static void HandleParam(Type genericTType, Type genericIEnumerableTType, MethodInfo method, ParameterInfo parameter) {
			if (parameter.IsOut)
				if (parameter.ParameterType == genericTType)
					_tryDeserialize = new FunctionWrapper(method);
				else if (parameter.ParameterType == genericIEnumerableTType)
					_tryDeserializeRepeatable = new FunctionWrapper(method);
		}

		/// <summary>
		/// Attempts to deserialize a <paramref name="m"/> to a <typeparamref name="TItem"/>, and returns whether or not it can.
		/// </summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="m">The message.</param>
		/// <param name="result">The result after deserialization</param>
		/// <returns><c>true</c> if it can deserialize it, <c>false</c> if it can't</returns>
		public static bool TryDeserializeItem<TItem>(BaseMessage m, out TItem result) {
			if (m is null) throw new ArgumentNullException(nameof(m));

			var def = MessageManager.GetDefinitionFor<TItem>();

			if (def is null) {
				result = default;
				return false;
			}

			// attrib checking
			if (!EnsureAttributesOn(m, def)) {
				result = default;
				return false;
			}

			// ensure strict message amount for IEnumerable support reasons
			if (m.Count != def.MaxCount) {
				result = default;
				return false;
			}

			return TryDeserializeValue<TItem>(m, def, out result);
		}

		/// <summary>
		/// Attempts to deserialize the <paramref name="m"/> to a <typeparamref name="IEnumerable{TItem}"/>, and returns whether or not it can.
		/// </summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="m">The message.</param>
		/// <param name="result">The result after deserialization</param>
		/// <returns><c>true</c> if it can deserialize it, <c>false</c> if it can't</returns>
		public static bool TryDeserializeItems<TItem>(BaseMessage m, out TItem[] result) {
			if (m is null) throw new ArgumentNullException(nameof(m));

			var def = MessageManager.GetDefinitionFor<TItem>();

			if (def is null) {
				result = default;
				return false;
			}

			// attrib checking
			if (!EnsureAttributesOn(m, def) ||
				!def.Repeatable) {
				result = default;
				return false;
			}

			return TryDeserializeValues<TItem>(m, def, out result);
		}

		#region reflectionified

		public static bool TryDeserializeItem(Type t, BaseMessage m, out object result) {
			if (t is null) throw new ArgumentNullException(nameof(t));
			if (m is null) throw new ArgumentNullException(nameof(m));

			var args = new object[] { m, null };

			var method = _tryDeserialize.GetMethodFor(t);

			if (!(bool)(method(null, args))) {
				result = default;
				return false;
			}

			result = args[1];

			return true;
		}

		public static bool TryDeserializeItems(Type t, BaseMessage m, out object[] result) {
			if (t is null) throw new ArgumentNullException(nameof(t));
			if (m is null) throw new ArgumentNullException(nameof(m));

			var args = new object[] { m, null };

			if (!(bool)(_tryDeserializeRepeatable.GetMethodFor(t)(null, args))) {
				result = default;
				return false;
			}

			result = (object[])args[1];

			return true;
		}

		#endregion reflectionified

		private static bool TryDeserializeValue<T>(BaseMessage m, MessageDefinition def, out T result) {
			var max = 0;

			// prevent boxing calls
			var instance = (object)InstanceOf<T>.Create();

			foreach (var i in def.Properties) {
				if (PropertyQualifies(i, m))
					i.Set(instance, m.Arguments[i.IntPos]);
				else if (i.State == TypeRequiredness.Required) {
					result = default;
					return false;
				}
			}

			result = (T)instance;
			return true;
		}

		private static bool TryDeserializeValues<T>(BaseMessage m, MessageDefinition def, out T[] result) {
			var max = m.Count / def.IntMaxCount;

			var itms = new T[max];

			for (var i = 0; i < max; i++) {
				var messageItems = new object[def.IntMaxCount];

				Array.Copy(m.Arguments, i * def.IntMaxCount, messageItems, 0, def.IntMaxCount);

				if (!TryDeserializeValue<T>(new BasicMessage(null, messageItems), def, out T item)) {
					result = default;
					return false;
				}

				itms[i] = item;
			}

			result = itms;
			return true;
		}

		private static bool PropertyQualifies(MessageProperty prop, BaseMessage m)
			=> m.Arguments.Length > prop.IntPos &&
				prop.PropertyInfo.PropertyType == m.Arguments[prop.Position]?.GetType();

		private static bool EnsureAttributesOn(BaseMessage m, MessageDefinition def)
			=> m.Type == def.Type;
	}
}
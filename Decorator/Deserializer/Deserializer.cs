using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Decorator {

	/// <summary>
	/// Deserializes any message to a type.
	/// </summary>
	/// <typeparam name="TClass">The type of the class.</typeparam>
	/// <autogeneratedoc />
	public static class Deserializer {

		static Deserializer() => GruntWorker = new DeserializationGrunt();

		/// <summary>The type manager. Don't screw with it. It should be internal but I'm letting it be public. Thank me, peasant..</summary>
		public static DeserializationGrunt GruntWorker { get; }

		/// <summary>
		/// Attempts to deserialize a <paramref name="m"/> to a <typeparamref name="TItem"/>, and returns whether or not it can.
		/// </summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="m">The message.</param>
		/// <param name="result">The result after deserialization</param>
		/// <returns><c>true</c> if it can deserialize it, <c>false</c> if it can't</returns>
		public static bool TryDeserialize<TItem>(BaseMessage m, out TItem result)
			=> GruntWorker.TryDeserialize<TItem>(m, out result);

		/// <summary>
		/// Attempts to deserialize the <paramref name="m"/> to a <typeparamref name="IEnumerable{TItem}"/>, and returns whether or not it can.
		/// </summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="m">The message.</param>
		/// <param name="result">The result after deserialization</param>
		/// <returns><c>true</c> if it can deserialize it, <c>false</c> if it can't</returns>
		public static bool TryDeserializeMultiple<TItem>(BaseMessage m, out IEnumerable<TItem> result)
			=> GruntWorker.TryDeserializeRepeatable<TItem>(m, out result);
	}

	/// <summary>Deserializes any message to a method in the TClass</summary>
	/// <typeparam name="TClass">The type of the class.</typeparam>
	public static class Deserializer<TClass>
		where TClass : class {

		static Deserializer()
			=> MethodDeserializerManager = new MethodDeserializerManager<TClass>();

		private static readonly FunctionWrapper _objToArray = new FunctionWrapper(
				typeof(Deserializer<TClass>)
					.GetMethod(nameof(FromObjToArray), BindingFlags.Static | BindingFlags.NonPublic)
			);

		public static MethodDeserializerManager<TClass> MethodDeserializerManager { get; }

		/// <summary>
		/// Invokes any methods in the <see cref="TClass"/> <paramref name="instance"/> that have the <seealso cref="Attributes.DeserializedHandlerAttribute"/> attribute and accept the <typeparamref name="TItem"/> parameter as input.
		/// </summary>
		/// <typeparam name="TItem">The item to use</typeparam>
		/// <param name="instance">The instance of the <typeparamref name="TClass"/> to deserialize it to (use null for static)</param>
		/// <param name="item">The item to use to invoke stuff</param>
		public static void DeserializeItemToMethod<TItem>(TClass instance, TItem item) {
			foreach (var i in MethodDeserializerManager.GetMethodsFor<TItem>()) {
				MethodDeserializerManager.InvokeMethod<TItem>(i, instance, item);
			}
		}

		/// <summary>
		/// Invokes any methods with the <seealso cref="Attributes.DeserializedHandlerAttribute"/> attribute if the <paramref name="msg"/> can be deserialized to the first parameter in the method.
		/// </summary>
		/// <param name="instance">The instance of the <typeparamref name="TClass"/> to deserialize it to (use null for static)</param>
		/// <param name="msg">The message</param>
		public static void DeserializeMessageToMethod(TClass instance, BaseMessage msg) {
			var instanceObj = (object)instance;

			foreach (var i in MethodDeserializerManager.Cache) {
				if (i.Key.GenericTypeArguments.Length > 0) {
					var genArg = i.Key.GenericTypeArguments[0];

					if (typeof(IEnumerable).IsAssignableFrom(i.Key) &&
						Deserializer.GruntWorker.TryDeserializeRepeatableType(genArg, msg, out var enumerable)) {
						var result = _objToArray.GetMethodFor(genArg)(null, new[] { enumerable });

						foreach (var k in i.Value)
							MethodDeserializerManager.InvokeMethod(k, instanceObj, result);
					}
				} else if (Deserializer.GruntWorker.TryDeserializeType(i.Key, msg, out var itm)) {
					foreach (var k in i.Value)
						MethodDeserializerManager.InvokeMethod(k, instanceObj, itm);
				}
			}
		}

		private static IEnumerable<T> FromObjToArray<T>(IEnumerable<object> objs)
			=> FromObj<T>(objs).ToArray();

		private static IEnumerable<T> FromObj<T>(IEnumerable<object> objs) {
			foreach (var i in objs)
				yield return (T)i;
		}
	}
}
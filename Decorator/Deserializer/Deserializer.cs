using Decorator.Exceptions;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Decorator {

	/// <summary>
	/// Deserializes any message to a type.
	/// </summary>
	/// <typeparam name="TClass">The type of the class.</typeparam>
	/// <autogeneratedoc />
	public static class Deserializer {
		static Deserializer() => TypeManager = new MessageManager();

		/// <summary>The type manager. Don't screw with it. It should be internal but I'm letting it be public. Thank me, peasant..</summary>
		public static MessageManager TypeManager { get; }

		/// <summary>If you can deserialize the message to a <typeparamref name="TItem"/>.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="m">The message.</param>
		/// <returns><c>true</c> if this instance can deserialize the specified m; otherwise, <c>false</c>.</returns>
		/// <autogeneratedoc />
		public static bool CanDeserialize<TItem>(BaseMessage m)
			=> CanDeserialize(typeof(TItem), m);

		/// <summary>If you can deserialize the message to an <see cref="IEnumerable{TItem}"/>.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="m">The message.</param>
		/// <returns><c>true</c> if this instance can deserialize the specified m; otherwise, <c>false</c>.</returns>
		/// <autogeneratedoc />
		public static bool CanDeserializeRepeats<TItem>(BaseMessage m)
			=> CanDeserializeRepeats(typeof(TItem), m);

		/// <summary>Deserializes the specified message, and throws an exception if it can't.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="m">The message.</param>
		/// <returns></returns>
		/// <exception cref="Exceptions.InvalidDeserializationAttemptException">Thrown if the BaseMessage doesn't qualify as a <typeparamref name="TItem"/></exception>
		/// <autogeneratedoc />
		public static TItem Deserialize<TItem>(BaseMessage m)
					where TItem : new()
			=> (TItem)Deserialize(typeof(TItem), m);

		/// <summary>Deserializes a message to an <see cref="IEnumerable{TItem}"/>.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="m">The message.</param>
		/// <returns></returns>
		/// <exception cref="Exceptions.InvalidDeserializationAttemptException">Thrown if the BaseMessage doesn't qualify as a <typeparamref name="TItem"/></exception>
		/// <autogeneratedoc />
		public static IEnumerable<TItem> DeserializeRepeats<TItem>(BaseMessage m) where TItem : new()
			=> FromObj<TItem>(DeserializeRepeats(typeof(TItem), m)).ToArray();

		/// <summary>
		/// Attempts to deserialize a <paramref name="m"/> to a <typeparamref name="TItem"/>, and returns whether or not it can.
		/// </summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="m">The message.</param>
		/// <param name="result">The result after deserialization</param>
		/// <returns><c>true</c> if it can deserialize it, <c>false</c> if it can't</returns>
		public static bool TryDeserialize<TItem>(BaseMessage m, out TItem result) {
			var pass = TryDeserialize(typeof(TItem), m, out var tryDesRes);

			result = pass ?
				(TItem)tryDesRes
				: default;

			return pass;
		}

		/// <summary>
		/// Attempts to deserialize the <paramref name="m"/> to a <typeparamref name="IEnumerable{TItem}"/>, and returns whether or not it can.
		/// </summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="m">The message.</param>
		/// <param name="result">The result after deserialization</param>
		/// <returns><c>true</c> if it can deserialize it, <c>false</c> if it can't</returns>
		public static bool TryDeserializeRepeats<TItem>(BaseMessage m, out IEnumerable<TItem> result) {
			var pass = TryDeserializeRepeats(typeof(TItem), m, out var tryDesRes);

			result = pass ?
				FromObj<TItem>(tryDesRes)
				: default;

			return pass;
		}

		public static bool CanDeserialize(Type t, BaseMessage m)
			=> TypeManager.QualifiesAsType(t, m);

		public static bool CanDeserializeRepeats(Type t, BaseMessage m)
			=> TypeManager.QualifiesAsRepeatableType(t, m);

		public static object Deserialize(Type t, BaseMessage m) {
			if (CanDeserialize(t, m))
				return TypeManager.DeserializeToType(t, m);

			throw new InvalidDeserializationAttemptException();
		}

		public static IEnumerable<object> DeserializeRepeats(Type t, BaseMessage m) {
			if (TypeManager.QualifiesAsRepeatableType(t, m))
				return TypeManager.DeserializeRepeatableToType(t, m).ToArray();

			throw new InvalidDeserializationAttemptException();
		}

		public static bool TryDeserialize(Type t, BaseMessage m, out object result) {
			if (TypeManager.QualifiesAsType(t, m)) {
				result = TypeManager.DeserializeToType(t, m);
				return true;
			}
			result = default;
			return false;
		}

		public static bool TryDeserializeRepeats(Type t, BaseMessage m, out IEnumerable<object> result) {
			if (TypeManager.QualifiesAsRepeatableType(t, m)) {
				result = TypeManager.DeserializeRepeatableToType(t, m).ToArray();
				return true;
			}
			result = default;
			return false;
		}

		private static IEnumerable<T> FromObj<T>(IEnumerable<object> objs) {
			foreach (var i in objs)
				yield return (T)i;
		}
	}

	/// <summary>Deserializes any message to a method in the TClass</summary>
	/// <typeparam name="TClass">The type of the class.</typeparam>
	public static class Deserializer<TClass>
		where TClass : class {

		static Deserializer() {
			MethodDeserializerManager = new MethodDeserializerManager<TClass>();
			_objToArrays = new Cache<Type, Func<object, object[], object>>();
			_objToArray = typeof(Deserializer<TClass>)
								.GetMethod(nameof(FromObjToArray), BindingFlags.Static | BindingFlags.NonPublic);
		}

		private static readonly MethodInfo _objToArray;

		private static readonly Cache<Type, Func<object, object[], object>> _objToArrays;

		public static MethodDeserializerManager<TClass> MethodDeserializerManager { get; }

		#region imitate Deserializer
		public static bool CanDeserialize<TItem>(BaseMessage m)
			=> Deserializer.CanDeserialize<TItem>(m);

		public static bool CanDeserializeRepeats<TItem>(BaseMessage m)
			=> Deserializer.CanDeserializeRepeats<TItem>(m);

		public static TItem Deserialize<TItem>(BaseMessage m)
					where TItem : new()
			=> Deserializer.Deserialize<TItem>(m);

		public static IEnumerable<TItem> DeserializeRepeats<TItem>(BaseMessage m) where TItem : new()
			=> Deserializer.DeserializeRepeats<TItem>(m);

		public static bool TryDeserialize<TItem>(BaseMessage m, out TItem result)
			=> Deserializer.TryDeserialize<TItem>(m, out result);

		public static bool TryDeserializeRepeats<TItem>(BaseMessage m, out IEnumerable<TItem> result)
			=> Deserializer.TryDeserializeRepeats<TItem>(m, out result);

		public static bool CanDeserialize(Type t, BaseMessage m)
			=> Deserializer.CanDeserialize(t, m);

		public static bool CanDeserializeRepeats(Type t, BaseMessage m)
			=> Deserializer.CanDeserializeRepeats(t, m);

		public static object Deserialize(Type t, BaseMessage m)
			=> Deserializer.Deserialize(t, m);

		public static IEnumerable<object> DeserializeRepeats(Type t, BaseMessage m)
			=> Deserializer.DeserializeRepeats(t, m);

		public static bool TryDeserialize(Type t, BaseMessage m, out object result)
			=> Deserializer.TryDeserialize(t, m, out result);

		public static bool TryDeserializeRepeats(Type t, BaseMessage m, out IEnumerable<object> result)
			=> Deserializer.TryDeserializeRepeats(t, m, out result);
		#endregion

		/// <summary>
		/// Invokes any methods in the <see cref="TClass"/> <paramref name="instance"/> that have the <seealso cref="Attributes.DeserializedHandlerAttribute"/> attribute and accept the <typeparamref name="TItem"/> parameter as input.
		/// </summary>
		/// <typeparam name="TItem">The item to use</typeparam>
		/// <param name="instance">The instance of the <typeparamref name="TClass"/> to deserialize it to (use null for static)</param>
		/// <param name="item">The item to use to invoke stuff</param>
		public static void DeserializeItemToMethod<TItem>(TClass instance, TItem item) {
			foreach (var i in MethodDeserializerManager.GetMethodsFor<TItem>()) {
				MethodDeserializerManager.InvokeMethod<TItem>(i, instance, item);
			}
		}

		/// <summary>
		/// Invokes any methods with the <seealso cref="Attributes.DeserializedHandlerAttribute"/> attribute if the <paramref name="msg"/> can be deserialized to the first parameter in the method.
		/// </summary>
		/// <param name="instance">The instance of the <typeparamref name="TClass"/> to deserialize it to (use null for static)</param>
		/// <param name="msg">The message</param>
		public static void DeserializeMessageToMethod(TClass instance, BaseMessage msg) {
			foreach (var i in MethodDeserializerManager.Cache) {
				if (Deserializer.TypeManager.QualifiesAsType(i.Key, msg)) {
					var des = Deserializer.TypeManager.DeserializeToType(i.Key, msg);

					foreach (var k in i.Value)
						MethodDeserializerManager.InvokeMethod(k, instance, des);
				}

					// if it works as whatevever the key is, it ***certainly*** won't work as an IEnuemrable<>
					else

					if (i.Key.GenericTypeArguments.Length > 0) {
					var genArg = i.Key.GenericTypeArguments[0];

					if (typeof(IEnumerable).IsAssignableFrom(i.Key) &&
						Deserializer.TypeManager.QualifiesAsRepeatableType(genArg, msg)) {
						var des = Deserializer.TypeManager.DeserializeRepeatableToType(genArg, msg);

						var result = _objToArrays.Retrieve(genArg, () =>
							IL.Wrap(_objToArray.MakeGenericMethod(genArg)))
							(null, new[] { des });

						foreach (var k in i.Value)
							MethodDeserializerManager.InvokeMethod(k, (object)instance, result);
					}
				}
			}
		}

		private static IEnumerable<T> FromObjToArray<T>(IEnumerable<object> objs)
			=> FromObj<T>(objs).ToArray();

		private static IEnumerable<T> FromObj<T>(IEnumerable<object> objs) {
			foreach (var i in objs)
				yield return (T)i;
		}
	}
}
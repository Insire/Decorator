using Decorator.Attributes;
using Decorator.Exceptions;

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Decorator {

	/// <summary>
	/// Caches System.Reflection calls for speed improvements
	/// </summary>
	/// <typeparam name="TClass">The type of the class.</typeparam>
	/// <autogeneratedoc />
	public class MethodDeserializerManager<TClass>
		where TClass : class {
		private readonly Type _tclassType = typeof(TClass);

		public MethodDeserializerManager() {
			this.Cache = new ConcurrentDictionary<Type, MethodInfo[]>();

			this.MethodInfoCache = new ConcurrentDictionary<MethodInfo, Action<object, object>>();

			//TODO: clean
			// with like a reflection helper class
			// or something

			var dict = new Dictionary<Type, List<MethodInfo>>();

			foreach (var i in this._tclassType.GetMethods().Where(x => AttributeCache<DeserializedHandlerAttribute>.HasAttribute(x)))
				if (dict.TryGetValue(i.GetParameters()[0].ParameterType, out var val))
					val.Add(i);
				else dict[i.GetParameters()[0].ParameterType] = new List<MethodInfo> { i };

			foreach (var i in dict) {
				this.Cache.TryAdd(i.Key, i.Value.ToArray());
			}
		}

		/// <summary>Gets the cache.</summary>
		/// <value>The cache.</value>
		/// <autogeneratedoc />
		public ConcurrentDictionary<Type, MethodInfo[]> Cache { get; }

		/// <summary>Gets the method information cache.</summary>
		/// <value>The method information cache.</value>
		/// <autogeneratedoc />
		public ConcurrentDictionary<MethodInfo, Action<object, object>> MethodInfoCache { get; }

		/// <summary>Gets the methods.</summary>
		/// <returns></returns>
		/// <autogeneratedoc />
		public MethodInfo[] GetMethods() => this.Cache.SelectMany(x => x.Value).ToArray();

		/// <summary>Gets the methods for.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <returns></returns>
		/// <autogeneratedoc />
		public MethodInfo[] GetMethodsFor<TItem>()
			=> this.GetMethodsFor(typeof(TItem));

		/// <summary>Gets the methods for.</summary>
		/// <param name="item">The item.</param>
		/// <returns></returns>
		/// <autogeneratedoc />
		public MethodInfo[] GetMethodsFor(Type item) {
			if (this.Cache.TryGetValue(item, out var res)) return res;
			throw new LackingMethodsException(item);
		}

		/// <summary>Invokes the method.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="method">The method.</param>
		/// <param name="instance">The instance.</param>
		/// <param name="item">The item.</param>
		/// <autogeneratedoc />
		public void InvokeMethod<TItem>(MethodInfo method, TClass instance, TItem item)
			=> this.InvokeMethod(method, (object)instance, item);

		/// <summary>Invokes the method.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="method">The method.</param>
		/// <param name="instance">The instance.</param>
		/// <param name="item">The item.</param>
		/// <autogeneratedoc />
		public void InvokeMethod<TItem>(MethodInfo method, object instance, TItem item) {
			if (!this.MethodInfoCache.TryGetValue(method, out var invoke)) {
				invoke = method
							.GetSingleInvokable();

				this.MethodInfoCache.TryAdd(method, invoke);
			}

			invoke(instance, item);
		}
	}
}
using Decorator.Exceptions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Decorator {

	/// <summary>
	/// Caches System.Reflection calls for speed improvements
	/// </summary>
	/// <typeparam name="TClass">The type of the class.</typeparam>
	/// <autogeneratedoc />
	public class MethodDeserializerManager<TClass>
		where TClass : class {

		public MethodDeserializerManager() {
			this.Cache = new Cache<Type, MethodInfo[]>();

			this.MethodInfoCache = new Cache<MethodInfo, Func<object, object[], object>>();

			//TODO: clean
			// with like a reflection helper class
			// or something

			this._cast = this.GetType().GetMethod(nameof(CastObj), BindingFlags.NonPublic | BindingFlags.Static);

			var dict = new Dictionary<Type, List<MethodInfo>>();

			foreach (var i in typeof(TClass).GetMethods().Where(x => x.HasAttribute<Attributes.DeserializedHandlerAttribute>(out var _)))
				if (dict.TryGetValue(i.GetParameters()[0].ParameterType, out var val))
					val.Add(i);
				else dict[i.GetParameters()[0].ParameterType] = new List<MethodInfo> { i };

			foreach (var i in dict)
				this.Cache.Retrieve(i.Key, () => i.Value.ToArray());
		}

		private readonly MethodInfo _cast;

		/// <summary>Gets the cache.</summary>
		/// <value>The cache.</value>
		/// <autogeneratedoc />
		public Cache<Type, MethodInfo[]> Cache { get; }

		/// <summary>Gets the method information cache.</summary>
		/// <value>The method information cache.</value>
		/// <autogeneratedoc />
		public Cache<MethodInfo, Func<object, object[], object>> MethodInfoCache { get; }

		/// <summary>Gets the methods.</summary>
		/// <returns></returns>
		/// <autogeneratedoc />
		public MethodInfo[] GetMethods() => this.Cache.SelectMany(x => x.Value).ToArray();

		/// <summary>Gets the methods for.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <returns></returns>
		/// <autogeneratedoc />
		public MethodInfo[] GetMethodsFor<TItem>()
			=> GetMethodsFor(typeof(TItem));

		/// <summary>Gets the methods for.</summary>
		/// <param name="item">The item.</param>
		/// <returns></returns>
		/// <autogeneratedoc />
		public MethodInfo[] GetMethodsFor(Type item)
			=> this.Cache.Retrieve(item, () => {
				throw new LackingMethodsException(item);
			});

		/// <summary>Invokes the method.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="method">The method.</param>
		/// <param name="instance">The instance.</param>
		/// <param name="item">The item.</param>
		/// <autogeneratedoc />
		public void InvokeMethod<TItem>(MethodInfo method, TClass instance, TItem item)
			=> InvokeMethod(method, (object)instance, item);

		/// <summary>Invokes the method.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="method">The method.</param>
		/// <param name="instance">The instance.</param>
		/// <param name="item">The item.</param>
		/// <autogeneratedoc />
		public void InvokeMethod<TItem>(MethodInfo method, object instance, TItem item) {
			var d = this.MethodInfoCache.Retrieve(method, () =>
				IL.Wrap(method));

			d(instance, new object[] { item });
		}

		private static T CastObj<T>(object input)
			=> (T)input;
	}
}
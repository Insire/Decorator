using Decorator.Attributes;
using Decorator.Caching;
using Decorator.Exceptions;

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Decorator {

	/// <summary>
	/// Caches System.Reflection calls for speed improvements
	/// </summary>
	/// <typeparam name="TClass">The type of the class.</typeparam>
	/// <autogeneratedoc />
	internal static class MethodInvoker<TClass>
		where TClass : class {
		private static readonly Type _tclassType = typeof(TClass);

		static MethodInvoker() {
			Cache = new ConcurrentHashcodeDictionary<Type, MethodInfo[]>();

			MethodInfoCache = new ConcurrentHashcodeDictionary<MethodInfo, Action<object, object>>();

			//TODO: clean
			// with like a reflection helper class
			// or something

			var dict = new Dictionary<Type, List<MethodInfo>>();

			foreach (var i in _tclassType.GetMethods().Where(x => AttributeCache<DeserializedHandlerAttribute>.HasAttribute(x)))
				if (dict.TryGetValue(i.GetParameters()[0].ParameterType, out var val))
					val.Add(i);
				else dict[i.GetParameters()[0].ParameterType] = new List<MethodInfo> { i };

			foreach (var i in dict) {
				Cache.TryAdd(i.Key, i.Value.ToArray());
			}
		}

		/// <summary>Gets the cache.</summary>
		/// <value>The cache.</value>
		/// <autogeneratedoc />
		public static ConcurrentHashcodeDictionary<Type, MethodInfo[]> Cache;

		/// <summary>Gets the method information cache.</summary>
		/// <value>The method information cache.</value>
		/// <autogeneratedoc />
		public static ConcurrentHashcodeDictionary<MethodInfo, Action<object, object>> MethodInfoCache;

		/// <summary>Gets the methods.</summary>
		/// <returns></returns>
		/// <autogeneratedoc />
		public static MethodInfo[] GetMethods() => Cache.SelectMany(x => x.Value).ToArray();

		/// <summary>Gets the methods for.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <returns></returns>
		/// <autogeneratedoc />
		public static MethodInfo[] GetMethodsFor<TItem>()
			=> GetMethodsFor(typeof(TItem));

		/// <summary>Gets the methods for.</summary>
		/// <param name="item">The item.</param>
		/// <returns></returns>
		/// <autogeneratedoc />
		public static MethodInfo[] GetMethodsFor(Type item) {
			if (Cache.TryGetValue(item, out var res)) return res;
			throw new LackingMethodsException(item);
		}

		/// <summary>Invokes the method.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="method">The method.</param>
		/// <param name="instance">The instance.</param>
		/// <param name="item">The item.</param>
		/// <autogeneratedoc />
		public static void InvokeMethod<TItem>(MethodInfo method, TClass instance, TItem item)
			=> InvokeMethod(method, (object)instance, item);

		/// <summary>Invokes the method.</summary>
		/// <typeparam name="TItem">The type of the item.</typeparam>
		/// <param name="method">The method.</param>
		/// <param name="instance">The instance.</param>
		/// <param name="item">The item.</param>
		/// <autogeneratedoc />
		public static void InvokeMethod<TItem>(MethodInfo method, object instance, TItem item) {
			if (!MethodInfoCache.TryGetValue(method, out var invoke)) {
				invoke = method
							.GetSingleInvokable();

				MethodInfoCache.TryAdd(method, invoke);
			}

			invoke(instance, item);
		}
	}
}
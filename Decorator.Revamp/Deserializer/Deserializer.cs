using Decorator.Exceptions;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Decorator {

	/// <summary>
	/// Deserializes any message to the type of the class. You only need one per class type.
	/// </summary>
	/// <typeparam name="TClass">The type of the class.</typeparam>
	/// <autogeneratedoc />
	public class Deserializer<TClass>
		where TClass : class {

		public Deserializer() {
			this.TypeManager = new MessageManager();
			this.MethodDeserializerManager = new MethodDeserializerManager<TClass>();
			this._objToArrays = new Cache<Type, Func<object, object[], object>>();
			this._objToArray = this.GetType()
								.GetMethod(nameof(FromObjToArray), BindingFlags.Static | BindingFlags.NonPublic);
		}

		private MethodInfo _objToArray;

		private Cache<Type, Func<object, object[], object>> _objToArrays;

		public MessageManager TypeManager { get; }

		public MethodDeserializerManager<TClass> MethodDeserializerManager { get; }

		public bool CanDeserialize<TItem>(BaseMessage m)
			=> CanDeserialize(typeof(TItem), m);

		public bool CanDeserializeRepeats<TItem>(BaseMessage m)
					=> CanDeserializeRepeats(typeof(TItem), m);

		public TItem Deserialize<TItem>(BaseMessage m)
					where TItem : new()
			=> (TItem)Deserialize(typeof(TItem), m);

		public IEnumerable<TItem> DeserializeRepeats<TItem>(BaseMessage m) where TItem : new()
			=> FromObj<TItem>(DeserializeRepeats(typeof(TItem), m)).ToArray();

		public bool CanDeserialize(Type t, BaseMessage m)
							=> this.TypeManager.QualifiesAsType(t, m);

		public bool CanDeserializeRepeats(Type t, BaseMessage m)
			=> this.TypeManager.QualifiesAsRepeatableType(t, m);

		public object Deserialize(Type t, BaseMessage m) {
			if (this.CanDeserialize(t, m))
				return this.TypeManager.DeserializeToType(t, m);

			throw new DecoratorException("no");
		}

		public IEnumerable<object> DeserializeRepeats(Type t, BaseMessage m) {
			if (this.TypeManager.QualifiesAsRepeatableType(t, m))
				return this.TypeManager.DeserializeRepeatableToType(t, m).ToArray();

			throw new DecoratorException("nooo");
		}

		public void DeserializeItemToMethod<TItem>(TClass instance, TItem item) {
			foreach (var i in this.MethodDeserializerManager.GetHandlersFor<TItem>()) {
				this.MethodDeserializerManager.InvokeMethod<TItem>(i, instance, item);
			}
		}

		public void DeserializeMessageToMethod(TClass instance, BaseMessage msg) {
			foreach (var i in this.MethodDeserializerManager.Cache) {
				if (this.TypeManager.QualifiesAsType(i.Key, msg)) {
					dynamic des = this.TypeManager.DeserializeToType(i.Key, msg);

					foreach (var k in i.Value)
						this.MethodDeserializerManager.InvokeMethod(k, instance, des);
				}

					// if it works as whatevever the key is, it ***certainly*** won't work as an IEnuemrable<>
					else

					if (i.Key.GenericTypeArguments.Length > 0) {
					var genArg = i.Key.GenericTypeArguments[0];

					if (i.Key == typeof(IEnumerable<>).MakeGenericType(genArg) &&
						this.TypeManager.QualifiesAsRepeatableType(genArg, msg)) {
						var des = this.TypeManager.DeserializeRepeatableToType(genArg, msg);

						dynamic result = this._objToArrays.Retrieve(genArg, () =>
							IL.Wrap(this._objToArray.MakeGenericMethod(genArg)))
							(null, new[] { des });

						foreach (var k in i.Value)
							this.MethodDeserializerManager.InvokeMethod(k, (object)instance, result);
					}
				}
			}
		}

		private static IEnumerable<T> FromObjToArray<T>(IEnumerable<object> objs)
			=> FromObj<T>(objs).ToArray();

		private static IEnumerable<T> FromObj<T>(IEnumerable<object> objs) {
			foreach (var i in objs)
				yield return (T)i;
		}
	}
}